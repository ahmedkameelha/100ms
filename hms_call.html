<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>100ms Video Call (robust loader)</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
  <style>
    :root{
      --bg:#0f0f10; --panel:#161616; --muted:#888; --accent:#ea4335; --surface:#202020; color-scheme: dark;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:system-ui,Arial}
    #status-container{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.75);z-index:50;transition:opacity .25s}
    #top-bar{display:flex;justify-content:space-between;align-items:center;padding:10px 14px;background:var(--panel);border-bottom:1px solid #222}
    #user-info{font-size:0.95rem}
    #video-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:10px;padding:12px;flex:1;overflow:auto;height:calc(100vh - 144px)}
    .video-tile{position:relative;background:var(--surface);border-radius:10px;overflow:hidden;min-height:140px;display:flex;align-items:center;justify-content:center}
    .video-tile video{width:100%;height:100%;object-fit:cover;display:none}
    .video-tile.local video{transform:scaleX(-1)}
    .avatar-placeholder{width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:2.2rem;background:#2a2a2a}
    .tile-overlay{position:absolute;left:8px;right:8px;bottom:8px;display:flex;justify-content:space-between;align-items:center;padding:6px;border-radius:8px;background:rgba(0,0,0,.45);font-weight:500}
    .mute-icon i{color:var(--accent)}
    .controls{display:flex;gap:12px;justify-content:center;padding:12px;background:var(--panel);border-top:1px solid #222}
    .control-btn{width:52px;height:52px;border-radius:50%;border:0;background:#2b2b2b;color:#fff;display:flex;align-items:center;justify-content:center;cursor:pointer;font-size:18px}
    .control-btn:hover{filter:brightness(1.08)}
    .control-btn.toggled-off{background:var(--accent)}
    #participant-count{margin-left:6px;color:var(--muted)}
    /* small responsive tweaks */
    @media (max-width:540px){ .video-tile{min-height:120px} .avatar-placeholder{font-size:1.4rem} }
  </style>
</head>
<body>
  <div id="status-container"><span id="status">Loading SDK & connecting…</span></div>

  <div id="top-bar">
    <div id="user-info">Guest | <span id="call-timer">00:00</span></div>
    <div><i class="fa-solid fa-users"></i><span id="participant-count">0</span></div>
  </div>

  <div id="video-grid"></div>

  <div class="controls">
    <button id="mic-btn" class="control-btn"><i class="fa-solid fa-microphone"></i></button>
    <button id="cam-btn" class="control-btn"><i class="fa-solid fa-video"></i></button>
    <button id="end-call-btn" class="control-btn"><i class="fa-solid fa-phone-slash"></i></button>
  </div>

  <script>
  /*********************************************************
   * Robust SDK loader + complete app
   * - loads primary SDK, falls back to a secondary bundle if needed
   * - waits for SDK to be available before doing any destructuring
   * - defensive guards against undefined peer lists
   **********************************************************/
  const PRIMARY_SDK = 'https://unpkg.com/@100mslive/hms-video-store@latest/dist/hms-video-store.umd.js';
  const FALLBACK_SDK = 'https://cdn.jsdelivr.net/gh/ahmedkameelha/hmsweb@f09a25e53fb1f373631533a97e763cf1bde205e4/hms-bundle.js';

  // DOM refs
  const statusContainer = document.getElementById('status-container');
  const statusEl = document.getElementById('status');
  const videoGrid = document.getElementById('video-grid');
  const participantCountEl = document.getElementById('participant-count');
  const callTimerEl = document.getElementById('call-timer');

  // HMS runtime vars
  let hmsManager = null, hmsStore = null, hmsActions = null;
  let callStartTime = null, callTimerInterval = null;

  // utility: load script
  function loadScript(url){
    return new Promise((resolve,reject)=>{
      const s = document.createElement('script');
      s.src = url;
      s.async = true;
      s.onload = () => resolve(url);
      s.onerror = () => reject(new Error('Failed loading ' + url));
      document.head.appendChild(s);
    });
  }

  // Start initialization sequence: try primary, then fallback
  (async function boot(){
    try {
      statusEl.textContent = 'Loading 100ms SDK…';
      await loadScript(PRIMARY_SDK);
      if (!window.HMSReactiveStore) throw new Error('HMSReactiveStore not found after primary SDK load');
      statusEl.textContent = 'SDK loaded. Connecting…';
      await initHMS(); // proceed when SDK exists
    } catch (err) {
      console.warn('Primary SDK failed:', err);
      try {
        statusEl.textContent = 'Loading fallback SDK…';
        await loadScript(FALLBACK_SDK);
        if (!window.HMSReactiveStore) throw new Error('HMSReactiveStore still not found after fallback');
        statusEl.textContent = 'Fallback SDK loaded. Connecting…';
        await initHMS();
      } catch (err2) {
        console.error('Both SDK loads failed:', err2);
        statusEl.textContent = 'Error loading 100ms SDK. See console.';
      }
    }
  })();

  // Initialize after SDK is present
  async function initHMS() {
    try {
      // destructure selectors from loaded SDK (safe now)
      const {
        selectPeers,
        selectIsLocalAudioEnabled,
        selectIsLocalVideoEnabled,
        selectIsConnectedToRoom,
      } = window.HMSReactiveStore;

      // read room from URL
      const params = new URLSearchParams(window.location.search);
      const roomId = params.get('roomId');
      const userName = params.get('userName') || 'Guest';
      if (!roomId) throw new Error('roomId is required in the URL ( ?roomId=xxxx )');

      // set user display
      document.getElementById('user-info').firstChild
        ? document.getElementById('user-info').childNodes[0].textContent = `${userName} | `
        : document.getElementById('user-info').textContent = `${userName} | `;

      // create manager and store
      hmsManager = new window.HMSReactiveStore();
      hmsManager.triggerOnSubscribe();
      hmsStore = hmsManager.getStore();
      hmsActions = hmsManager.getHMSActions();

      // get token and join (your backendless helper getAuthTokenByRoomCode assumed available in bundle)
      const authToken = await hmsActions.getAuthTokenByRoomCode({ roomCode: roomId });

      // join with audio/video enabled (browser may still block audio until user gesture)
      await hmsActions.join({
        userName,
        authToken,
        settings: { isAudioMuted: false, isVideoMuted: false }
      });

      // subscribe to store updates using selectors from SDK
      hmsStore.subscribe(onConnectionUpdate, selectIsConnectedToRoom);
      hmsStore.subscribe(renderPeers, selectPeers);
      hmsStore.subscribe(updateMicButton, selectIsLocalAudioEnabled);
      hmsStore.subscribe(updateCamButton, selectIsLocalVideoEnabled);

      // hide status overlay (onConnectionUpdate will also hide when connected)
      statusEl.textContent = 'Connected (waiting for peer updates)…';
    } catch (err) {
      console.error('HMS Init Error:', err);
      statusEl.textContent = 'Init Error: ' + (err.message || err);
    }
  }

  // connection state
  function onConnectionUpdate(isConnected) {
    if (isConnected) {
      statusContainer.style.opacity = '0';
      statusContainer.style.pointerEvents = 'none';
      if (!callStartTime) {
        callStartTime = Date.now();
        startCallTimer();
      }
    } else {
      statusContainer.style.opacity = '1';
      statusContainer.style.pointerEvents = 'auto';
      stopCallTimer();
      callTimerEl.textContent = '00:00';
      videoGrid.innerHTML = '';
      participantCountEl.textContent = '0';
    }
  }

  function startCallTimer(){
    if (callTimerInterval) return;
    callTimerInterval = setInterval(()=>{
      const elapsed = Math.max(0, Date.now() - (callStartTime || Date.now()));
      const s = Math.floor(elapsed/1000);
      const mStr = String(Math.floor(s/60)).padStart(2,'0');
      const sStr = String(s%60).padStart(2,'0');
      callTimerEl.textContent = `${mStr}:${sStr}`;
    }, 1000);
  }
  function stopCallTimer(){
    if (callTimerInterval) { clearInterval(callTimerInterval); callTimerInterval = null; }
    callStartTime = null;
  }

  // render peers (defensive)
  function renderPeers(peers) {
    if (!Array.isArray(peers)) return;
    videoGrid.innerHTML = '';
    participantCountEl.textContent = String(peers.length || 0);

    peers.forEach(peer => {
      const tile = document.createElement('div');
      tile.className = 'video-tile';
      if (peer.isLocal) tile.classList.add('local');

      const videoEl = document.createElement('video');
      videoEl.autoplay = true;
      videoEl.muted = !!peer.isLocal;
      videoEl.playsInline = true;

      const avatar = document.createElement('div');
      avatar.className = 'avatar-placeholder';
      avatar.textContent = (peer.name && peer.name.charAt(0)) ? peer.name.charAt(0).toUpperCase() : '?';

      tile.appendChild(videoEl);
      tile.appendChild(avatar);

      // Attach video if track present and enabled. Keep avatar when disabled.
      if (peer.videoTrack) {
        if (peer.videoTrack.enabled) {
          // attachVideo expects trackId (bundle's API)
          try {
            hmsActions.attachVideo(peer.videoTrack.trackId, videoEl)
              .then(()=>{ avatar.style.display='none'; videoEl.style.display='block'; })
              .catch(e=>{ console.warn('attachVideo error', e); avatar.style.display='flex'; videoEl.style.display='none'; });
          } catch(e){
            console.warn('attachVideo threw', e);
            avatar.style.display='flex';
            videoEl.style.display='none';
          }
        } else {
          avatar.style.display='flex';
          videoEl.style.display='none';
        }
      } else {
        avatar.style.display='flex';
        videoEl.style.display='none';
      }

      // overlay: name + mute
      const overlay = document.createElement('div');
      overlay.className = 'tile-overlay';
      const nameSpan = document.createElement('span');
      nameSpan.textContent = peer.isLocal ? 'You' : (peer.name || 'Guest');
      overlay.appendChild(nameSpan);

      if (!peer.audioTrack || !peer.audioTrack.enabled) {
        const muteDiv = document.createElement('div');
        muteDiv.className = 'mute-icon';
        muteDiv.innerHTML = '<i class="fa-solid fa-microphone-slash"></i>';
        overlay.appendChild(muteDiv);
      }
      tile.appendChild(overlay);
      videoGrid.appendChild(tile);
    });
  }

  // update buttons UI
  function updateMicButton(isEnabled) {
    const btn = document.getElementById('mic-btn');
    btn.classList.toggle('toggled-off', !isEnabled);
    btn.querySelector('i').className = isEnabled ? 'fa-solid fa-microphone' : 'fa-solid fa-microphone-slash';
  }
  function updateCamButton(isEnabled) {
    const btn = document.getElementById('cam-btn');
    btn.classList.toggle('toggled-off', !isEnabled);
    btn.querySelector('i').className = isEnabled ? 'fa-solid fa-video' : 'fa-solid fa-video-slash';
  }

  // control handlers (wait for store existence)
  document.getElementById('mic-btn').addEventListener('click', async ()=>{
    if (!hmsStore || !hmsActions) { console.warn('HMS not ready'); return; }
    try {
      const { selectIsLocalAudioEnabled } = window.HMSReactiveStore;
      const current = hmsStore.getState(selectIsLocalAudioEnabled) ?? false;
      await hmsActions.setLocalAudioEnabled(!current);
    } catch(e){ console.warn(e); }
  });

  document.getElementById('cam-btn').addEventListener('click', async ()=>{
    if (!hmsStore || !hmsActions) { console.warn('HMS not ready'); return; }
    try {
      const { selectIsLocalVideoEnabled } = window.HMSReactiveStore;
      const current = hmsStore.getState(selectIsLocalVideoEnabled) ?? false;
      await hmsActions.setLocalVideoEnabled(!current);
    } catch(e){ console.warn(e); }
  });

  document.getElementById('end-call-btn').addEventListener('click', async ()=>{
    if (!hmsActions) return;
    try {
      await hmsActions.leave();
      stopCallTimer();
      statusEl.textContent = 'You left the room.';
      statusContainer.style.opacity = '1';
      statusContainer.style.pointerEvents = 'auto';
    } catch(e){ console.warn(e); }
  });

  // clean up on unload
  window.addEventListener('beforeunload', ()=>{ if (hmsActions) hmsActions.leave().catch(()=>{}); });
  </script>
</body>
</html>
